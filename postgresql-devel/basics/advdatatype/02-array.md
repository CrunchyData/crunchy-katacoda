If you're a programmer, you know that an array holds a _list_ or _collection_ 
of values. In Postgres, the array can hold a set of values of other data types 
(i.e. a set of integers, or enums, or even user-defined types). 

With that said, while some programming languages such as JavaScript allow 
different data types within the same array, in Postgres the array elements are 
of the **same** type.

### Declare array type

We've decided that our `career_interests` column in the client table should use
 the array type. This lets us store **multiple** career interest text values 
per person, instead of storing them as one long text string, and perhaps doing 
something like parsing the string using delimiters (e.g. commas) to 
actually get each individual interest.

Let's create the first table in our example:

```
CREATE TABLE client (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	first VARCHAR(50) NOT NULL,
	last VARCHAR(50),
	email VARCHAR(80) NOT NULL,
    career_interests TEXT[] NOT NULL
);
```{{execute}}

The simplest way to set the column type to an array is to add square brackets `[]`
 to the type name (e.g. `text`) for the array elements. This is what we did in 
 CREATE TABLE above. 
 
While you can specify an array size, e.g. `career_interests[5]`, Postgres 
won't actually enforce it. If you needed to limit the number of array 
elements, you could use a [CHECK constraint](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS).

### Add array values

Let's add some records to our table:

```
INSERT INTO client (first, last, email, career_interests) 
    VALUES ('Wilhelmina', 'Wybrow', 'wwybrow0@elegantthemes.com', '{"Programming", "Project Management", "Web Development"}'),
        ('Domenic', 'Perotti', 'dperotti2@blog.com', '{"Athletic coaching", "personal training"}'),
        ('Mart', 'Wellbelove', 'mwellbelove3@ibm.com', '{"Computer Programming", "Data Science"}'),
        ('Ricky', 'MacGillivray', 'rmacgillivray4@eepurl.com', '{"Counseling"}'),
        ('Nina', 'Ferrand', 'nferrand5@lycos.com', '{"Music", "Audio engineering", "Radio", "Film Production", "Screenwriting"}');
```{{execute}}

There are two ways to add array values to a table. One is to use curly braces 
enclosed by quotes (as we've done above): 

> '{value1 delimiter value2 delimiter value3 ...}'

The delimiter for almost all data types is the comma (`,`).

The other way is to use the [ARRAY constructor](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS), e.g.:

> INSERT INTO client (career_interests)
VALUES (ARRAY ['Social media', 'Communications', 'PR'])

Note the differences in syntax between the two methods:
* curly braces (`{}`), versus square brackets (`[]`),
* double quotes (`""`) around literals inside the braces, versus single quotes 
(`''`) around literals inside the brackets
* enclose curly brackets in single quotes

### Query arrays

Let's start with a simple SELECT on the table:

```
SELECT * FROM client;
```{{execute}}

You'll notice that the text values that contain whitespaces (e.g. `Project 
Management`) are enclosed by double quotes. Numeric arrays won't contain 
quotes, but textual arrays may. The [official docs](https://www.postgresql.org/docs/current/arrays.html#ARRAYS-IO) 
has details on how array values are outputted.

Array elements each have within the array. Postgres uses a **one-based** 
numbering convention for arrays; that is, the first array element is 
`array[1]`, and the last of **n** elements is `array[n]`.

So, you could access the first career interest for clients like so:

```
SELECT 
    first,
    last,
    career_interests[1]
FROM client;
```{{execute}}

With that said, that's not particularly helpful for our case, so let's look at 
a couple of functions that come in handy for arrays.
